$Id$

Улучшенные perl-хуки для hpt
                 редакция 1.3

1. Предисловие
2. Общие константы и функции
3. Функции, вызываемые по событиям из hpt
4. История изменений
5. Дополнительные perl-модули и программы

  --------------------------------------------------------------------
  1. Предисловие

  Улучшенные perl-хуки - это почти полная переработка perl-хуков hpt (далее
  они названы стандартными perl-хуками). Они дают возможность реализовать на
  hpt функциональность сложного трекера (например, ftrack) и сделать шаблоны
  ответов на запросы areafix. 

  Если Вы использовали стандартные perl-хуки, то, скорее всего, Вам
  не придется ничего менять, т.к. имеется почти полная совместимость. Однако
  лучше на всякий случай почитать раздел 4. Крайне рекомендуется также перейти
  от использования строковых дат и флагов на бинарные, от функций myaddr() и
  nodelistDir() к соотв. параметрам $config{}. Если же у Вас перестало что-то
  работать при переходе на новые perl-хуки, то свяжитесь с автором:
                    val khokhlov, 2:550/180, val(at)vk(dot)kiev(dot)ua

  --------------------------------------------------------------------
  2. Общие константы и функции

  Флаги письма задаются в виде следующих констант:
PVT, CRA, RCV, SNT, ATT, TRS, ORP, K_S, LOC, HLD, RSV, FRQ, RRQ, RRC, ARQ, URQ,
A_S, DIR, ZON, HUB, IMM, XMA, KFS, TFS, LOK, CFM, HIR, COV, SIG, LET
  Их можно использовать либо как переменные ($PVT, $A_S), в т.ч. в строках;
  либо как вызовы функций (PVT, A_S), но только в обычном коде (не в строках
  или regex'ах) и при условии подключения модуля vtrack.

  Кроме того, для целей определения flavour, могут быть использованы
  численные значения флагов:
  CRA - crash, HLD - hold, DIR или CRA|HLD - direct, IMM - immediate
  Любое другое ненулевое число (и не строка!) воспринимается как normal

  В perl-коде можно использовать следующие read-only переменные:

  $hpt_ver     - версия hpt в таком виде: "hpt 1.2.0-stable/bsd"
  $hpt_version - версия hpt так, как она выводится самой программой
  %config      - хэш, в который записываются переменные из конфига:
    $config{inbound}
    $config{protInbound}
    $config{localInbound}
    $config{outbound}
    $config{name}
    $config{sysop}
    $config{origin}
    $config{logDir}
    $config{dupeHistoryDir}
    $config{nodelistDir}
    $config{tempDir}
    $config{sortEchoList} - 
    $config{areafixFromPkt} - 1 если установлен параметр, иначе не определен
    $config{areafixNames} - список, разделенный запятыми
    $config{robotsArea}
    $config{reportTo}
    $config{keepTrsMail} - 1 если установлен параметр, иначе не определен
    $config{keepTrsFiles} - 1 если установлен параметр, иначе не определен
    $config{fileBoxesDir}
    $config{rulesDir}
  %links       - хэш, в котором для каждого линка из конфига хранится
                 хэш его переменных, e.g. $links{'2:550/180'}{'name'}
                 (первым ключом служит aka линка, т.е. hisAka)
    $links{}{name}     - имя из Links
    $links{}{aka}      - наше aka, которое подставляется линку (ourAka)
    $links{}{password} - пароль из password
    $links{}{filebox}  - файлбокс для линка
    $links{}{flavour}  - flavour линка, берется из netMailFlavour, 
                         в виде флага (см.выше)
    $links{}{eflavour} - echo flavour линка, берется из echoMailFlavour, 
    $links{}{pause}    - 1 если установлен %pause на эхи, иначе неопределен
    $links{}{level}
    $links{}{advAfix}  - 1 если у линка advanced areafix, иначе неопределен
    $links{}{echoLimit}
    $links{}{groups}   - список доступных линку групп, разделенных пробелами
  %areas       - хэш, в котором хранятся параметры эхообластей (ключ - эхотаг)
    $areas{}{desc}     - описание эхи
    $areas{}{aka}      - используемая для эхи aka
    $areas{}{group}    - группа
    $areas{}{hide}     - 1 если прятать эху в списке (%list)
    $areas{}{passthrough} - 1 если эха passthrough
    $areas{}{mandatory}
    $areas{}{manual}
    $areas{}{lvl_r}    - мин.уровень доступа для чтения сообщений
    $areas{}{lvl_w}    - мин.уровень доступа для отсылки сообщений
    %areas{}{links}    - хэш линков, подключенных к данной эхе
                         ключ - адрес линка
                         значение - параметры линка, битовое поле [00eiMmU1]
                                    U (бит 2) - default uplink
                                    m (бит 3) - линк в режиме manual
                                    M (бит 4) - линк в режиме mandatory
                                    i (бит 5) - линк может писать сообщения
                                    e (бит 6) - линку отсылаются сообщения
  %groups      - хэш, который содержит описания групп (токен grpDesc)
                 ключ - имя группы, значение - описание
                 
   Функции общего назначения:

  w_log([$level, ]$s) - записать строку в лог
      Параметры:
      $level - уровень (один символ), если не задан - используется LL_PERL
      $s     - строка


  str2attr($s) - преобразует строку с атрибутами в численное значение
      Параметры:
      $s - строка, в которой через пробел перечислены флаги ("sent" и т.п.)
  Использование этой функции не рекомендуется, лучше использовать числовые
  значения флагов.


  attr2str($attr) - выдает строковое представление флагов письма
      Параметры:
      $attr - флаги в бинарном виде
  Возращается строка трехсимвольных обозначений флагов, разделенных пробелами.
  Трехсимвольные обозначения: Pvt Cra K/s Rrq Att (аттач) Tfs A/S Sig и т.п.


  flv2str($flag) - выдает строковое представление flavour
      Параметры:
      $flag - представление flavour в виде бинарного флага письма
              (то, что хранится в $links{}{flavour}) или в виде строки
  Возвращаемые значения: IMM=>immediate, CRA=>crash, HLD=>hold, DIR=>direct,
  любое другое=>normal


  myaddr() - возвращает массив адресов данной системы
  Используйте @{$config{addr}} вместо вызова данной функции.


  nodelistDir() - возвращает каталог с нодлистом, т.е. nodelistDir из конфига
  Используйте $config{nodelistDir} вместо вызова данной функции.


  crc32($s) - возвращает crc-32 от аргумента по основанию -1
      Параметры:
      $s - строка, от которой нужно вычислить crc32
           длина строки определяет размер области памяти, от которого
           вычисляется crc


  alike($s1, $s2) - возвращает расстояние по Левенштейну между словами
                    (0-полное совпадение)
  Может быть использована для реализации нечеткой карбонки.
  Hапример: alike("HPT","JT")


  date_fts($dt) - перевод даты/времени из unixtime в формат fts-1
      Параметры:
      $dt - unixtime
  Возвращаемый формат: "dd mmm yy  hh:mm:ss", mmm - Jan, Feb, Mar...
  Не рекомендуется использовать дату/время в строковом виде в перл-хуках,
  для этого там есть соответствующий unixtime.


  fts_date($s) - перевод даты/времени из строки в формате fts-1 в unixtime
      Параметры:
      $s - строка, ожидается в формате "dd mmm yy  hh:mm:ss"
  Вообще, парсер из hpt может отпарсить дату и в некоторых других форматах
  либо вытащить хотя бы часть полей. Если вообще ничего не получится, то
  функция вернет undef.
  Не рекомендуется использовать дату/время в строковом виде в перл-хуках,
  для этого там есть соответствующий unixtime.


  mktime($sec, $min, $hour, $mday, $mon, $year[, $wday[, $yday[, $dst]]])
         - возвращает unixtime из своих аргументов
      Параметры:
      $sec  - секунды (00..59)
      $min  - минуты  (00..59)
      $hour - часы    (00..23)
      $mday - день месяцы (00..31)
      $mon  - месяц (00..11), 0 - январь
      $year - год (0..69 - для 2000..2069, >1900 - реальный год,
                   70..1900 - 1970..3800, т.е. 1900+значение)
      $wday - день недели (0..6), только для совместимости
      $yday - день года (0..365), только для совместимости
      $dst  - признак daylight saving time (0..1), только для совместимости
  Функция возвращает unixtime или 0 в случае ошибки.
  Для чего нужно 9 параметров? Если вызывать mktime(localtime), то
  используются все возвращаемые localtime 9 параметров, при этом корректно
  обрабатывается переход на летнее/зимнее время.
  Внимание! При использовании модуля POSIX могут возникнуть накладки, т.к.
  там такая функция тоже определена. Не импортируйте последнюю.


  strftime($format, [$unixtime])
  strftime($format, $sec, $min, $hour, $mday, $mon, $year[, $wday[, $yday[, $dst]]])
           - преобразует время в строку согласно формата
      Параметры:
      $format   - формат, см. man strftime
      $unixtime - использовать unixtime, если не задан - текущее время
      остальные - см. mktime
  Внимание! При использовании модуля POSIX могут возникнуть накладки, т.к.
  там такая функция тоже определена. Не импортируйте последнюю.


  gmtoff([$dt]) - возвращает разницу в часах между местным временем и
                  UTC (+3 означает, что у нас на 3 часа больше, чем GMT)
      Если задан параметр $dt, то расчет выполняется на заданное им время
  (обратите внимание - может учитываться переход на летнее/зимнее время).
  Если он не задан - разница по состоянию на сейчас.
      Технически вычисляется как разница между localtime() и gmtime().
  Может неправильно работать при разнице +-11..12 часов. Также, если есть
  разница в минутах, то возвращаемое значение будет не целым числом, т.е.
  +4.5 означает разницу в 4 часа 30 минут.


  putMsgInArea($area, $fromname, $toname, $fromaddr, $toaddr, $subject, 
               $date, $attr, $text[, $addkludges])
  * при использовании модуля vtrack имеет алиас post()
  - создает новое письмо в базе
      Параметры:
      $area              - тэг области, как записано в Area
                           если параметр не задан - первая нетмэйл-область
      $fromname, $toname - имена отправителя и получателя
      $fromaddr, $toaddr - соответствующие адреса
                           если $fromaddr = undef, берем aka для области
      $subject           - subj :)
      $date              - дата письма (unixtime)
                           если 0 или undef, берем текущую
                           также поддерживается для совместимости дата в виде
                           строки в формате fts-1
      $attr              - флаги письма (см. константы PVT, LOC, ...)
                           также поддерживаются для совместимости флаги в
                           виде строки
      $text              - текст
      $addkludges        - режим работы с кладжами (по умолчанию - 2):
          0 - текст письма не меняется (рекомендуется использовать его для
              копирования/перемещения существующих сообщений)
          1 - в текст письма вставляются кладжи INTL, TOPT, FMPT, FLAGS, MSGID,
              отражающие поля $fromaddr, $toaddr, $flags; если такие кладжи
              в письме уже есть, они вырезаются (рекомендуется использовать его
              при генерации нового письма на основании существующего: forward)
          2 - в текст письма вставляются только те кладжи INTL, TOPT, FMPT,
              MSGID, которых там не было; в FLAGS добавляются установленные в
              $attr флаги, но не удаляются обнуленные в $attr (используется,
              если нужно задать часть кладжей вручную)
          3 - в тесте письма обновляются кладжи INTL, TOPT, FMPT, FLAGS
              согласно параметров $toaddr, $fromaddr, $attr; причем сохраняется
              порядок кладжей (рекомендуется использовать его при изменении
              флагов или переадресации без создания нового сообщения)
  В тексте письма все пары '\r\n' и одиночные символы '\n' заменяются на '\r' 
  (в соответствии с fts1 символ '\n' будет игнорироваться).
  Если письмо создано успешно, то возвращается undef. Иначе - строка с
  сообщением об ошибке.

  --------------------------------------------------------------------
  3. Функции, вызываемые по событиям из hpt

  После компиляции скрипта осуществляется поиск всех имеющихся в нем
  функций из тех, что перечислены ниже. Если какой-то из них нет, то данное
  событие в перл не передается. Если во время выполнения какой-либо функции
  произошла ошибка (она запишется в лог), то данное событие больше в перл
  не передается.

  Полный перечень всех определенных обработчиков:
   * hpt_start
   * hpt_exit
   * after_unpack
   * before_pack
   * process_pkt
   * pkt_done
   * filter
   * tossbad
   * put_msg
   * scan
   * export
   * route
   * on_echolist
   * on_afixcmd
   * on_afixreq

  hpt_start() - не имеет параметров, вызывается при запуске hpt

  Внимание! Кроме того, перед вызовом этой функции выполняется тело скрипта.

  hpt_exit()  - не имеет параметров, вызывается при завершении hpt

  after_unpack() - вызывается после распаковки бандла в TempInbound

  before_pack() - вызывается перед началом паковки бандлов в TempOutbound
                  на линков


  process_pkt() - вызывается перед тоссингом .pkt
    Определены следующие переменные:
       $pktname - имя pkt-файла
       $secure - определена (defined), если pkt получен по парольному линку
                 (либо через LocalInbound)
    Возврат:
       если возвращается непустая строка, то pkt переименовывается в .flt и не
       обрабатывается дальше.


  pkt_done() - вызывается после завершение обработки .pkt
    Определены следующие переменные:
       $pktname - имя pkt-файла (в момент вызова он еще существует)
       $rc - код результата (0-все OK и $res не определена)
       $res - строковое представление $rc (на английском)
    Коды результатов и их значение на русском:
       0 - OK ($res не определена)
       1 - нарушение секретности (например, неверный пароль)
       2 - сложности с открытием .pkt-файла
       3 - неверный формат .pkt (возможно он битый)
       4 - .pkt не для нашей системы
       5 - проблемы с тоссингом сообщения


  filter() - вызывается при тоссинге новых писем
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или undef
       $area             - область для эхомэйла, иначе - undef
       $secure           - текущие сообщение получено через SecureInbound
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $pktfrom          - от кого получен текущий pkt
    Возврат:
       $kill = 1         - удалить сообщение
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $area, $secure, $pktfrom :)
       если возвращается непустая строка, то письмо помещается в badArea с
       этой причиной
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  tossbad() - вызывается при тоссинге писем из badArea
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или undef
       $area             - область для эхомэйла, иначе - undef
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $pktfrom          - от кого получен pkt
    Возврат:
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $area, $secure, $pktfrom :)
       если возвращается непустая строка, то письмо удаляется с этой причиной
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  put_msg() - вызывается перед записью сообщения в локальную базу
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или наша aka для эхи
       $area             - область (тэг, который определен в конфиге)
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $netmail          - установлен в 1, если сообщение - нетмэйл
    Возврат:
       если возвращается 0 (или не число!), то письмо _не кладется_ в базу,
       в противном случае оно кладется в базу, причем можно установить:
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи
                           в случае нетмэйла)
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  scan() - вызывается при сканировании областей (hpt scan/hpt pack)
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя для нетмэйла или undef
       $area             - область, берется из Area
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
    Возврат:
       $addvia = 0       - не добавлять строку Via: (см. также route())
       $kill   = 1       - удалить письмо после завершения функции
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $area :)
       если возвращается непустая строка, то письмо не отсылается
  При изменении сообщения оно меняется только в памяти (т.е. hpt работает с
  измененным сообщением), но не в базе. Удаление письма работает как в случае
  его отсылки, так и в том случае, если оно не отсылается!
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  export() - вызывается перед отправкой сообщения эхоконференции на линка 
             (но _после_ создания служебных строк, в т.ч. SEEN-BY)
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес линка, которому направляется письмо
       $area             - область (тэг, который определен в конфиге)
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
    Возврат:
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (кроме $area и $toaddr)
       если возвращается непустая строка, то письмо не уходит на данного
       линка, а в лог пишется эта строка в качестве причины
  Не рекомендуется использовать атрибуты и дату/время в строковом виде.


  route() - вызывается при определении роутинга нетмейлового сообщения
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $from             - адрес отправителя
       $toname    $sto   - имя получателя
       $addr      $to    - адрес получателя
       $area             - область, берется из Area
       $subj             - subj
       $text             - текст сообщение(с кладжами)
       $date             - дата сообщения, переменная имеет два типа:
                           если используется как число - unixtime
                           если используется как строка - формат fts-1
       $attr             - атрибуты в виде числа
       $route            - роутинг из конфига, если он там есть ;)
    Возврат:
       $addvia = 0       - не добавлять строку Via:
       $change = 1       - изменить поля в соответствии с перечисленными
                           выше переменными (в т.ч. автоматом изменить кладжи)
                           (кроме $route :)
       $flavour          - спаковать письмо с данным flavour, который может
                           задаваться как атрибут (CRA, HLD, DIR, IMM) или
                           строка: c|cra|crash, h|hld|hold, d|dir|direct,
                           i|imm|immediate, n|norm|normal; по умолчанию hold
       если функция возвращает непустую строку, она считается адресом, на
  который пакуется данное письмо. Если же функция вернула пустую строку, но
  в конфиге не прописан роутинг, письмо никуда не отправляется.
       Переменная $addvia устанавливается в 1 до вызова scan(), ее можно
  поменять либо в scan(), либо в route(). Будучи установленной в 0, эта
  переменная отключает добавление строки Via: к упакованным письмам. К примеру,
  я добавляю строку Via: из route() с учетом моей aka для линка.


  on_echolist(type, tags, link, maxlen)
    - вызывается при генерации списка областей (%list, %query, %unlinked)
    Этой функции данные передаются в виде параметров (массив @_):
      #1 ($_[0]) - тип списка (0 - %list, 1 - %query, 2 - %unlinked)
      #2 ($_[1]) - указатель на массив тагов областей, которые вошли в список
                   в соответствии с текущим состоянием подписки в hpt
      #3 ($_[2]) - адрес линка, приславшего запрос
      #4 ($_[3]) - максимальная длина эхотага в массиве @{$_[1]} (параметр #2)
    Возвращаемое значение:
      0 - выдать список, который генерируется стандартными средствами hpt
      1 - отослать линку список, который находится в переменной $report
      2 - тело списка взять из переменной $report, а затем добавить к нему
          стандартную подпись (footer) hpt


  on_afixcmd(code, aka, line) - вызывается перед обработкой команды areafix'а
    Этой функции данные передаются в виде параметров (массив @_):
      #1 ($_[0]) - код команды (см. #define в areafix.h)
      #2 ($_[1]) - адрес линка, приславшего запрос
      #3 ($_[2]) - обрабатываемая строка запроса целиком
    Возвращаемое значение:
      0 - обработать команду в соответствии с логикой hpt
      1 - отослать линку содержимое переменной $report как результат
          обработки (стандартная логика hpt для этой строки отключается!)


  on_afixreq() - вызывается перед началом обработки запроса к areafix'у
    Определены следующие переменные:
       переменная алиас (vtrack)
       $fromname  $sfrom - имя отправителя
       $fromaddr  $from  - адрес отправителя
       $toname    $sto   - имя получателя
       $toaddr    $to    - адрес получателя
       $subject   $subj  - subj
       $text             - текст сообщение(с кладжами)
       $pktfrom          - от кого получен текущий pkt
    Возвращаемое значение
      0 - игнорировать изменения, обработать пришедший запрос
      1 - изменить значения в соответствии с переменными $text, $toname, 
          $fromname, $subject, $toaddr, $fromaddr и обработать запрос
    Внимание! Данная функция вызывается уже _после_ того, как запрос пройдет
    все проверки в hpt. Реально имеет смысл менять адрес линка ($fromname) и
    текст запроса ($text), т.к. остальные значения просто не используются hpt
    при дальнейшей обработке. При изменении адреса линка никаких дополнительных
    проверок не происходит, hpt ведет себя так, как если бы запрос пришел от
    этого линка с правильным паролем и т.п.
    PS: Не забывайте, что в $text строки разделяются символом '\r'.

  --------------------------------------------------------------------
  4. История зменений

  Исправления и дополнения по сравнению с редакцией 1.07
  улучшенных perl-хуков:

  1) добавились обработчики put_msg() и export();
  2) в putMsgInArea теперь на один '\r' заменяются как одиночные '\n', так
     и пары '\r\n' (раньше '\r\n' заменилось бы на '\r\r');
  3) use, require, do в перле при запуске hpt из другого каталога теперь будут
     искать модули/скрипты и в каталоге конфига или hptPerlFile

  Исправления и дополнения по сравнению с первой редакцией
  улучшенных perl-хуков:

  1) значительно расширен набор параметров конфига, доступных из перла;
  2) добавились обработчики on_echolist(), on_afixcmd() и on_afixreq();
  3) появилась возможность инклудить файлы в filter.pl через require или do.

  Исправления и дополнения по сравнению со стандартными perl-хуками

  1) вместо createKludges используется новая функция, которая не допускает
     глюков с дублированием кладжей, а также добавляет режимы 2 и 3
     !!! внимательно прочтите, для чего нужен тот или иной режим
  2) полностью поддерживаются расширенные флаги в кладже FLAGS
  3) все переменные, определяющие заголовок письма, в filter(), tossbad(),
     scan() и route() можно менять
  4) дата и флаги сделаны в двоичном виде, так и удобнее и быстрее
  5) если в стандартных хуках не было какой-то функции, это вызывало ошибку
  6) добавлена hpt_start() и выполнение тела основного скрипта
  7) возможность управлять добавлением строки Via: через $addvia
  8) все символы '\n' заменяются на '\r', как оговорено в fts1; в стандартных
     хуках они заменялись только тогда, когда в тексте не было ни одного '\r'
     !!! это очень важный момент - единственная несовместимость, которую я внес
  9) удаление писем в scan() при $kill=1

  --------------------------------------------------------------------
  5. Дополнительные perl-модули и программы

  Модуль nidx (nidx.pm)
  ---------------------
  Данный модуль реализует поиск узла в нодлисте (через индексацию нодлиста).
  По адресу узла возвращается информация о его хабе, регионе и строка 
  из нодлиста.

  Этот модуль требует модуль DB_File. В свою очередь, для DB_File нужен
  пакет BerkleyDB (обычно есть в unix); либо для win32 можно взять бинарник
  этого модуля. Если в системе есть BerkleyDB без поддержки btree, то нужно
  в строке 20 ($db = tie...) поменять $DB_BTREE на $DB_HASH (посл.параметр).

  Использование: use nidx [qw(<funcs>)];
  <funcs> - список функций, которые можно импортнуть в контекст main::,
            разделенных пробелами; доступны: soft_check hub region nodeline

  Функции:

  nidx::init($nodelistDir[[, h], \%opts]) - инициализирует индекс
     $nodelistDir - каталог с нодлистом (см. $config{nodelistDir})
     h            - имя переменной в контексте main::, которую нужно связать
                    с индексом
     %opts        - опции, могут быть следующие:
                      soft_net:  1 или 0 (см. ncheck(), по умолчанию 0)
                      soft_zone: 1 или 0 (см. ncheck(), по умолчанию 0)
                      ok_zone:   ссылка массив (см. ncheck(), по умолчанию [])
                      w_log:     если 1, то писать в лог hpt (по умолчанию 0)
     пример: nidx::init($config{nodelistDir}, nidx)
     после этого получаем %nidx, где $nidx{'2:550/180'} определена, если
     узел 2:550/180 присутствует в нодлистах.

  nidx::done() - закрывает файлы индекса

  nidx::update(@masks) - при необходимости обновляет индекс
     @masks - массив regex, определяющих маски файлов нодлистов
     пример: nidx::update("nodelist\.\d{3}", "net_463\.\d{3}")
     Внимание: информация об узле всегда берется из последнего по списку
     листа, в котором он присутствует.
     При необходимости после маски могут стоять зона и регион для данного
     листа через двоеточие, например: "net_463\.\d{3}:2:46". Если же в листе
     нет строчки "Zone," и/или "Region," и они не указаны, то будет плохо :)

  nidx::compile(@files) - компилирует файлы из массива в индекс
     @files - массив с именами файлов (с путями)
     Внимание: функция вызывается из update(), вряд ли ее нужно использовать
     отдельно
     При необходимости после маски могут стоять зона и регион для данного
     листа через двоеточие, например: "net_463\.291:2:46".

  nidx::nodelists() - возвращает массив имен текущих нодлистов в индексе

  nidx::ncheck($addr) - "мягкая" проверка наличия узла в листах
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает 1, если узел $addr есть в нодлистах. Кроме того, возвращает 1,
     если узел в нодлистах не найден, но выполняется "мягкая" проверка по
     любому из условий:
      * soft_net==1: такой сети нет, но такая зона есть
      * soft_zone==1: такой сети нет и такой зоны нет
      * такой сети нет и такой зоны нет, но зона присутствует в массиве ok_zone
      * индекс нодлиста не найден, скомпилировать его не удалось, но зона
        присутствует в массиве ok_zone
     Если же ни одно из условий не выполнилось, то возвращается undef.
  Например, установка параметров nidx::init(,,{soft_net=>1, ok_zone=>[1..6]})
  приведет к тому, что присутствующими в нодлисте будут считаться:
      - все найденные там узлы
      - все узлы в отсутствующих сетях зон 1..6 (есть сеть вдруг потерялась или
        используется только сетевой сегмент, а не весь нодлист)
      - все узлы в отсутствующих зонах 1..6 (есть компилится лишь сегмент зоны)

  nidx::hub($addr) - возвращает хаба для узла $addr
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает адрес хаба, в подхабнике которого находится узел. Для узлов в
     подхостнике возвращается адрес хоста. 
     Если узел не найден, но такая сеть есть, возвращается адрес хоста сети.
     Если сеть не найдена - undef.

  nidx::region($addr) - возвращает 2d-адрес региона для узла $addr
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает строку "zone:region" для узла. 
     Если узел не найден, но такая сеть есть - возвращает регион сети.
     Если сеть не найдена - возвращает undef;

  nidx::nodeline($addr) - возвращает строку из нодлиста для узла $addr
     $addr - 3d/4d адрес (он всегда приводится к 3d, так что "2:550/180.8" и
             "2:550/180" равноценны)
     Возвращает строку из последнего по списку листа, в котором присутствует
     данный узел. Если узел не найден или ошибка чтения строки - undef.


  Модуль vtrack (vtrack.pm)
  -------------------------
  Модуль, реализующий функции, требуемые нетмэйл-трекеру.

  Использование: use vtrack;

  Модуль определяет константы PVT, LOC, ..., LET. Кроме того, модуль
  устанавливает следующие алиасы (псевдонимы для функций и переменных):
    post  - алиас для функции putMsgInArea()
    from  - алиас для $fromaddr
    to    - алиас для $toaddr и $addr
    sfrom - алиас для $fromname
    sto   - алиас для $toname
    subj  - алиас для $subject

  Если в системе имеется модуль File::Basename, то из него импортируется
  функция basename (в контекст main::). Если такого модуля нет, то
  используется моя функция basename, которая работает с разделителями / и \.

  Функции:

  me($addr) - возвращает 1 если $addr - один из наших адресов, иначе - 0

  addvia([$link[, $utc]]) - добавляет строку Via: к письму
     $link - адрес линка, которому уходит письмо (в этом случае в строку
             Via подставляется наша aka для этого линка); если параметр не
             задан, то подставляется основной адрес
     $utc  - если 1, то время в строке Via указывается по UTC, иначе - местное

  age() - возвращает возраст письма в днях (по времени его написания)

  loop_cnt() - возвращает число прохождений письма через нашу систему, причем
               проверка идет по строке Via, по всем нашим адресам

  loop_age([$cnt]) - сколько дней назад письмо прошло через нашу систему 
     $cnt - если параметр задан, то возвращает кол-во дней с момента 
            $cnt-ого прохождения письма через нашу систему (нумерация с нуля), 
            undef в случае $cnt>=loop_cnt()
     если параметр не задан, возвращает массив, содержащий кол-во дней
     с моментов прохождения письма через нашу систему (в порядке строк Via)

  pack_age() - сколько часов назад письмо паковалось у нас последний раз
     функция смотрит последнюю строку Via, если она не нашей системы, то
     возвращается undef. Если же письмо последний раз паковалось на нашей
     системе, то возвращает разницу в часах с этого времени.

  att_check([$flags]) - проверяет наличие всех приаттаченных к письму файлов
     $flags - определяет, где искать файлы; по битам (по умолчанию - 3):
               бит 0 (0x01) : в секьюрном инбаунде (protInbound)
               бит 1 (0x02) : в обычном инбаунде (inbound)
               бит 2 (0x04) : в локальном инбаунде (localInbound)
     при этом, если в строке subj указаны пути к файлам, они игнорируются
     (берется только имя файла) и файлы все равно ищутся в инбаундах.
     Если данное письмо - не аттач, то возвращается 1.
     Если все файлы найдены, то возвращается 1. Иначе возвращается 0.

  att_cnt() - возвращает число приаттаченных к письму файлов
     возвращает undef, если письмо не аттач. Иначе разделяет строку subj по
     разделителям ' ' (пробел) и ',' и возвращает число непустых строк.

  att_size([$cnt[, $flags]]) - возвращает размер приаттаченного файла
     $cnt   - номер файла (нумерация начинается с нуля)
     $flags - где осуществлять поиск (см. att_check)
     если $cnt не задан, возвращается массив размеров всех приаттаченных
     файлов.
     Возвращает undef, если письмо не аттач, либо файл с таким номеров не
     найден, либо $cnt>=att_cnt(). Если $cnt не задан, то для ненайденных
     файлов соответствующий элемент возвращаемого массива будет undef.

  att_kill([$cnt[, $flags]]) - удаляет приаттаченный к письму файл
     $cnt   - номер файла (нумерация начинается с нуля)
     $flags - где осуществлять поиск (см. att_check)
     если $cnt не задан, удаляются все приаттаченные файлы.

  att_conv([$cnt]) - убирает пути к приаттаченным файлам
     $cnt   - номер файла (нумерация начинается с нуля)
     если $cnt не задан, удаляются все приаттаченные файлы.
  Внимание! Если не используется патч fidoconf_attach, то затем hpt все равно
  добавит путь к тому инбаунду, в котором найдет файл. В принципе, ничего
  страшного в этом обычно нет. Просто иногда могут файлы потеряться.


  Скрипт unpack.pl
  ----------------
  Скрипт выполняет распаковку bink-style outbound в каталог с fido-style базой
  сообщений (.msg). Обратите внимание - не opus, а fido-style!

  Параметры задаются в начале скрипта. Вот их описание:
  $DEF_ZONE - зона основного каталога outbound (зона из основного адреса)
  @OUTBOUND - массив каталогов bso, не нужно указывать в нем каталоги из
              других зон основного домена (т.е. outbound.xxx)
  $MSG_DIR  - каталог с .msg-базой, в которую распаковывать bso
  $STRIP_VIA- если установлен в 1, то последняя строка Via вырезается (обычно
              это строка Via от данного узла)
  $MAX_TRY  - сколько попыток предпринимать при наличии .bsy для узла
  $TRY_DELAY- задержка в секундах между попытками (см.выше)
  $LOG      - куда выводить лог работы скрипта (если не задано - в stdout)

  Скрипт пытается обнаружить и правильно обработать приаттаченные файлы. Если
  в пакете (.ut) найден аттач, то соответствующие ему файлы будут удалены из 
  .lo (конечно, если они там присутствуют).

